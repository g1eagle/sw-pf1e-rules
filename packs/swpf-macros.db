{"name":"useAction","permission":{"default":0,"fRudea7oGPoV9HaK":3},"type":"script","flags":{"pf1":{"itemMacro":true},"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.cwm7qQTkvwdX65SB"}},"scope":"global","command":"/*-\t\t\tDOCUMENTATION\t\t\t-*/\n// Syntax: [Select:] [<ActorOverride>:] <Action Name> [#<type>]\n// ie @Macro[useAction]{Manyshot #attack}\n// Action Name: \n//\t\tAll items on the character sheet will be searched.\n//\t\tThe first one to be found that contains an action will be used.\n//\t\tEnd with a \"?\" to get a prompt of available actions\n//\t\tPut parts in double quotes to mark them as required for fuzzy searches\n// Type (Optional, Prefixed by \"#\"):\n//\t\tIf not specified, it will not care and just return the first actionable action.\n//\t\tCapitilization does not matter here\n// ActorOverride (Optional, Suffixed by \":\"):\n//\t\tSets the remaining actions to use the overriden actor by name\n//\t\tIf not specified, will use the default target actor priority when searching (speaker, character, selected)\n//\t\tThis is case sensitive. You can reset back to default by providing the keyword \"My:\"\n//\t\tie @Macro[useAction]{His: Manyshot, AmmoCount, My: OP Dodge Ability}\n// Select:\n//\t\tTreats the remaining actions as a list of things to do\n// You may separate your actions by comma/semi-colon to execute multiple ie @Macro[useAction]{Magic Missile, Magic Missile, Crossbow}\n// If it can't find an exact match for action, it will use the first actionable item containing the name\n// Supports label mode. [[\"-El Diablo-, +5 Greatsword of Exploding\",1]]@Macro[useAction]{::Time to hit something}\n\n/*-\t\t\tCONFIGURATION\t\t\t-*/\nconst c = {\n\tcommands: {\n\t\tselect: \"Select\"\n\t},\n\tlabels: {\n\t\thideChargeless: \"Hide actions without enough charges\"\n\t}\n}\n\n/*-\t\t\tCOMMAND\t\t\t\t\t-*/\ntry {\n\tvar inputText = window.macroChain?.pop() || event.srcElement.closest('button,a')?.textContent.trim(),\n\t\tchatMessage = game.messages.get(event.srcElement.closest('.message')?.getAttribute('data-message-id')),\n\t\ttargetActor = canvas.tokens.objects?.children.find(o => o.id == chatMessage?.data.speaker?.token)?.actor ?? \n\t\t\tgame.actors.get(chatMessage?.data.speaker?.actor) ?? game.user.character ?? canvas.tokens.controlled[0]?.actor,\n\t\ttargetType = 'all',\n\t\tthisMacro = this.name,\n\t\targParse = /^(?:([^:]*):\\s*)?(.*?)(?: ?#(.*))?$/,\n\t\tactionList,\n\t\tallTypes = Object.fromEntries(game.system.entityTypes.Item.map(o => [o, game.i18n.localize('PF1.ItemType' + o.charAt(0).toUpperCase() + o.slice(1))]));\n\tif (inputText.indexOf('::') == 0)\n\t\tinputText = /['`\"](.*)['`\"],.*/.exec(event.srcElement.previousElementSibling?.title.trim())?.[1];\n\tif (inputText.indexOf(';') > -1)\n\t\tactionList = inputText.split(';').map(o => o.trim());\n\telse\n\t\tactionList = inputText.split(',').map(o => o.trim());\n}\ncatch (err) {\n\tconsole.log(err, \"Whatever you did didn't work\");\n}\n\nactionList.some((act, actIdx) => {\n\tvar [actorOverride, actionName, actionType] = act.match(argParse).slice(1),\n\t\tdoPrompt, dirtySearch;\n\tif (actionName.indexOf('?') > -1) {\n\t\tdoPrompt = true;\n\t\tactionName = actionName.replace('?','');\n\t}\n\tif (actionName.indexOf('\"') > -1) {\n\t\tactionName = actionName.replace(/\"([^\"]*)\"/g, (full,part) => {\n\t\t\tdirtySearch = dirtySearch?.concat(part) ?? [part];\n\t\t\treturn part;\n\t\t});\n\t}\n\tif (actionType)\n\t\tactionType = Object.keys(allTypes).find(o => allTypes[o].localeCompare(actionType, game.i18n.lang, {sensitivity: 'base'}) === 0);\n\tif (actorOverride) {\n\t\tif (actorOverride.toLowerCase() == 'my') targetActor = game.actors.get(chatMessage?.data.speaker?.actor) ?? game.user.character ?? canvas.tokens.controlled[0]?.actor;\n\t\telse if (actorOverride.localeCompare(c.commands.select, game.i18n.lang, {sensitivity: 'base'}) === 0)\n\t\t\treturn renderSelect([act.replace(actorOverride,'')].concat(actionList.slice(actIdx + 1)));\n\t\telse if (actorOverride.charAt(0) == '_') {\n\t\t\tlet actId, sceneId, tokId;\n\t\t\tactId = actorOverride.match(/_Actor\\.(.*)/)?.[1];\n\t\t\t[sceneId, tokId] = actorOverride.match(/_Scene\\.([^.]*).Token\\.(.*)/)?.slice(1) ?? [null, null];\n\t\t\ttargetActor = game.actors.get(actId) ?? targetActor;\n\t\t\tif (canvas.scene.id == sceneId)\n\t\t\t\ttargetActor = canvas.tokens.get('tokId').actor ?? targetActor;\n\t\t}\n\t\telse targetActor = game.actors.getName(actorOverride);\n\t}\n\tif (targetActor) {\n\t\tif (!targetActor.hasPerm(game.user, \"OWNER\")) return ui.notifications.warn(game.i18n.localize(\"PF1.ErrorNoActorPermission\"));\n\t\tvar backupAction = false,\n\t\t\titem = false,\n\t\t\tactionPrompts = [];\n\t\titem = targetActor.items.find(o => {\n\t\t\tvar lcItName = o.name.toLocaleLowerCase();\n            if (!backupAction && lcItName.indexOf(actionName.toLocaleLowerCase()) > -1)\n\t\t\t\tbackupAction = o;\n\t\t\tif (o.type != 'spell' && !o.isCharged && !o.hasAction) return false;\n\t\t\tif (actionType && actionType != o.type) return false;\n\t\t\tif (dirtySearch?.every(p => lcItName.indexOf(p.toLocaleLowerCase()) > -1))\n\t\t\t\tactionPrompts.push(o);\n\t\t\treturn o.name == actionName;\n\t\t});\n\t\tif (!item) {\n\t\t\tif (backupAction)\n\t\t\t\titem = backupAction;\n\t\t\telse if (actionPrompts.length > 0)\n\t\t\t\titem = actionPrompts[0];\n\t\t\telse if (actionName != '' && !dirtySearch)\n\t\t\t\tui.notifications.warn(game.i18n.format('PF1.WarningNoItemOnActor', [`\"${targetActor.name}\"`, `\"${actionName}\"`]));\n\t\t}\n\t\tif (doPrompt) {\n\t\t\ttargetType = item?.type ?? targetType;\n\t\t\tif (actionPrompts.length > 0)\n\t\t\t\treturn renderSelect(actionPrompts, item?.name, actionList.slice(actIdx + 1));\n\t\t\treturn renderSelect(targetActor.items.filter(o => o.type == targetType), item?.name, actionList.slice(actIdx + 1));\n\t\t}\n\t\telse {\n\t\t\tif (!item)\n\t\t\t\treturn ui.notifications.error(game.i18n.format('PF1.WarningNoItemOnActor', [`\"${targetActor.name}\"`, `\"${actionName}\"`]));\n\t\t\tif (!game.keyboard.isDown(\"Control\"))\n\t\t\t\titem.use({skipDialog: (game.settings.get(\"pf1\", \"skipActionDialogs\") !== game.keyboard.isDown(\"Shift\"))});\n\t\t\telse\n\t\t\t\titem.roll();\n\t\t}\n\t}\n});\n\nfunction renderSelect(selectActions, activeAction, remainingActions) {\n\tvar options = templateOptions(),\n\t\tdata = {}, hideUncharged = false,\n\t\td, parsedList, showName, showType, useUUID;\n\tif (!selectActions)\n\t\tselectActions = remainingActions;\n\tif (typeof selectActions[0] == 'string') {\n\t\tparsedList = selectActions.map(o => o.match(argParse).slice(1));\n\t\tshowName = parsedList.some(o => !!o[0] && o[0] != targetActor.name);\n\t\tshowType = parsedList.some(o => !!o[2] && o[2] != targetType);\n\t\tselectActions = parsedList.map(o => {\n\t\t\tlet t = {};\n\t\t\tlet key = (o[0] ? o[0] + ': ' : '') + o[1] + (o[2] ? ' #' + o[2] : '');\n\t\t\tlet val = (showName ? o[0] + ': ' : '') + o[1] + (showType ? ' #' + o[2] : ''); \n\t\t\treturn [key, val];\n\t\t});\n\t\tselectActions = Object.fromEntries(selectActions);\n\t}\n\telse if (selectActions[0] instanceof game.pf1.ItemPF) {\n\t\tif (selectActions[0].type == 'spell') hideUncharged = true;\n\t\tshowName = selectActions.some((o,idx) => !(idx == 0) && o.actor != selectActions[idx-1].actor);\n\t\tshowType = selectActions.some((o,idx) => !(idx == 0) && o.type != selectActions[idx-1].type);\n\t\tuseUUID = selectActions.some(o => o.actor.isToken && showName);\n\t\tselectActions = selectActions.map(o => {\n\t\t\tvar key = '', val = '';\n\t\t\tif (showName) {\n\t\t\t\tkey += (useUUID ? '_' + (o.actor.isToken ? o.token.uuid : o.uuid) : o.actor.name) + ': ';\n\t\t\t\tval += o.actor.name + ': ';\n\t\t\t}\n\t\t\tkey += o.name;\n\t\t\tval += o.name;\n\t\t\tif (showType) {\n\t\t\t\tkey += ' #' + allTypes[targetType];\n\t\t\t\tval += ' #' + allTypes[targetType];\n\t\t\t}\n\t\t\tif ((o.type == 'spell' && o.charges > 0) || (o.type != 'spell' && o.charges - o.chargeCost >= 0))\n\t\t\t\tval += ' (' + o.charges + ')';\n\t\t\treturn [key, val];\n\t\t});\n\t\tselectActions = Object.fromEntries(selectActions);\n\t}\n\tdata = {selectActions, activeAction, hideUncharged};\n\td = new Dialog({\n\t\ttitle: game.i18n.localize('PF1.ItemType' + targetType.charAt(0).toUpperCase() + targetType.slice(1)),\n\t\tcontent: _templateCache['macroChain/useAction'](data, options),\n\t\tbuttons: { \n\t\t\t'ok': {\n\t\t\t\ticon: '<i class=\"fas fa-check\"></i>',\n\t\t\t\tcallback: (htm) => {\n\t\t\t\t\tvar theRest = [htm[0].querySelector('select').value];\n\t\t\t\t\tif (remainingActions?.length > 0)\n\t\t\t\t\t\ttheRest = theRest.concat(remainingActions);\n\t\t\t\t\ttheRest = theRest.join(';');\n\t\t\t\t\twindow.macroChain = window.macroChain?.concat([theRest]) ?? [theRest];\n\t\t\t\t\tgame.macros.find(o => o.name == thisMacro)?.execute();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {width: 200});\n\tHooks.once('renderDialog', (a,inp) => {\n\t\tfunction hideChargeless(e) {\n\t\t\tlet checkChecked = e?.srcElement?.checked ?? e ?? true;\n\t\t\tlet options = [...inp[0].querySelectorAll('option')];\n\t\t\toptions.forEach(op => {if (!op.selected) op.style.display = !checkChecked || /\\(\\d+\\)$/.test(op.innerText) ? '' : 'none'; });\n\t\t}\n\t\tinp[0].querySelector('input[name=\"toggleCharged\"]').onchange = hideChargeless;\n\t\thideChargeless(hideUncharged);\n\t});\n\td.render(true);\n\treturn true;\n}\n\nfunction templateOptions() {\n\tif(!_templateCache['macroChain/useAction']) {\n\t\t_templateCache['macroChain/useAction'] = Handlebars.compile(\n`<form autocomplete=\"off\">\n\t<div class=\"form-group\">\n\t\t<label>{{localize \"PF1.ActionPlural\"}}: </label><div class=\"form-fields\">\n\t\t<select name=\"action\">\n\t\t{{#select activeAction}}\n\t\t\t{{#each selectActions}}\n\t\t\t<option value=\"{{@key}}\">{{this}}</option>\n\t\t\t{{/each}}\n\t\t{{/select}}\n\t\t</select>\n\t</div></div>\n\t<div class=\"form-group\">\n\t\t<label>${c.labels.hideChargeless}</label>\n\t\t<input type=\"checkbox\" name=\"toggleCharged\"{{#if hideUncharged}} checked{{/if}}>\n</div></form>`\n\t\t);\n\t}\n\treturn { allowProtoMethodsByDefault : true, allowProtoPropertiesByDefault: true };\n}","author":"fRudea7oGPoV9HaK","img":"icons/svg/mystery-man.svg","actorIds":[],"_id":"9wok1DmaRmpvVb6n"}
{"name":"Sneak Attack (Use Action Example)","permission":{"default":0,"fRudea7oGPoV9HaK":3},"type":"script","flags":{"pf1":{"itemMacro":true},"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":true},"core":{"sourceId":"Macro.bWfF5tNmo5PiOjiL"}},"scope":"global","command":"@Macro[useAction]{Sneak Attack #attack}","author":"fRudea7oGPoV9HaK","img":"icons/svg/mystery-man.svg","actorIds":[],"_id":"FIJmSQkIwBEBugZb"}
{"name":"Kitsune Shift","permission":{"default":0,"fRudea7oGPoV9HaK":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.gS3HDXfOZiJL13zk"}},"scope":"global","command":"// If you use Wild Shape, use the Wild Shape macro instead.\n\n// SETUP NEEDED: for each transformation option you want, please enter it as below\n// you also need to set imageFolder to the location of where you store your tokens.\n// token art is selected by name & as a png, so for example the image for Bat is located at 'assets/tokens/Bestiary/Bat.png'\n\n// you will also need to create a buff on your character sheet called \"Wild Shape (Auto)\".\n// This buff needs no details or changes & changes will be automatically overwritten\n\n// this macro will automatically unequip (and re-equip on Revert) your armour. It will check if the text \"Wild Armor\"\n// is in the armor description or title (and if so, will not unequip it). The macro will do the same for shields (and will\n// search them for \"Wild Armor\" )\n\n// for magical beasts (via beast shape 3 & 4), you will need to add another line to each magical beast's config, as seen on Death Worm\n// this line is magical: true (setting it to false or null will make the macro treat it as a normal beast)\n\nconst imageFolder = \"/tokens/Bestiary\";\n\nconst originalImage = \"/tokens/Eva-Token.png\";\nconst originalSize = \"medium\";\nconst kitsuneImage = \"/tokens/Bestiary/ArticKitsune.webp\";\n\nconst transformationOptions = {\n  ArticFox: {\n    size: \"tiny\",\n    spellSource: \"beast shape\",\n  },\n};\n\nconst sizes = [\"diminutive\", \"tiny\", \"small\", \"medium\", \"large\", \"huge\"];\n\nconst sizeTranslation = {\n  fine: \"fine\",\n  diminutive: \"dim\",\n  tiny: \"tiny\",\n  small: \"sm\",\n  medium: \"med\",\n  large: \"lg\",\n  huge: \"huge\",\n  gargantuan: \"grg\",\n  colossal: \"col\",\n};\n\nconst createSizeObject = ({ w, h, scale }) => {\n  return {\n    width: w,\n    height: h,\n    scale,\n  };\n};\n\nconst mediumOrBigger = (size) => {\n  return sizes.indexOf(size) >= sizes.indexOf(\"medium\");\n};\n\nconst createAbilityChange = (formula, subTarget) => {\n  formula = \"\" + formula;\n  return {\n    formula,\n    priority: 1,\n    target: \"ability\",\n    subTarget,\n    modifier: \"size\",\n  };\n};\n\nconst createNACChange = (formula) => {\n  formula = \"\" + formula;\n  return {\n    formula,\n    priority: 1,\n    target: \"ac\",\n    subTarget: \"nac\",\n    modifier: \"size\",\n  };\n};\n\nconst createSpeedChange = (formula, subTarget) => {\n  formula = \"\" + formula;\n  return {\n    formula,\n    priority: 1,\n    target: \"speed\",\n    subTarget,\n    modifier: \"size\",\n  };\n};\n\nconst createBuffChanges = (name) => {\n  const creature = transformationOptions[name];\n  const bulking = mediumOrBigger(creature.size);\n  let buffLevel = null;\n\n  const changes = [];\n\n  if (bulking) {\n    buffLevel = sizes.indexOf(creature.size) - sizes.indexOf(\"medium\") + 1;\n  } else {\n    buffLevel = sizes.indexOf(\"medium\") - sizes.indexOf(creature.size);\n  }\n\n  let mainBonus, nacBonus, penalty, mainBonusAbility, penaltyAbility;\n\n  if (creature.magical) {\n    if (creature.size === \"medium\") {\n      changes.push(createAbilityChange(buffLevel * 4, \"str\"));\n      changes.push(createNACChange(buffLevel * 4));\n    } else if (creature.size === \"large\") {\n      changes.push(createAbilityChange(buffLevel * 3, \"str\"));\n      changes.push(createAbilityChange(buffLevel, \"con\"));\n      changes.push(createAbilityChange(-buffLevel, \"dex\"));\n      changes.push(createNACChange(buffLevel * 3));\n    } else {\n      changes.push(createAbilityChange(buffLevel * 4, \"dex\"));\n      changes.push(createNACChange(buffLevel + 1));\n\n      if (buffLevel > 1) {\n        changes.push(createAbilityChange(-buffLevel, \"str\"));\n      }\n    }\n  } else {\n    mainBonus = buffLevel * 2;\n    nacBonus = bulking ? buffLevel * 2 : 1;\n    penalty = buffLevel > 1 ? -(buffLevel * 2 - 2) : 0;\n    mainBonusAbility = bulking ? \"str\" : \"dex\";\n    penaltyAbility = bulking ? \"dex\" : \"str\";\n\n    changes.push(createAbilityChange(mainBonus, mainBonusAbility));\n    changes.push(createAbilityChange(penalty, penaltyAbility));\n    changes.push(createNACChange(nacBonus));\n  }\n\n  return changes;\n};\n\nconst getWSBuff = (caster) => {\n  return caster.items.find(\n    (i) =>\n      i.type === \"buff\" &&\n      i.name.toLowerCase() === \"Wild Shape (Auto)\".toLowerCase()\n  );\n};\n\nconst setArmourAndShieldEquipStatus = (caster, status) => {\n  caster.items\n    .filter(\n      (item) =>\n        item.data.type === \"equipment\" &&\n        (item.data.data.equipmentType === \"armor\" ||\n          item.data.data.equipmentType === \"shield\")\n    )\n    .forEach((item) => {\n      // when disabling an item, only disable it if it doesn't have \"wild armo[u]r in its body somewhere. Always enable it.\n      if (\n        !status &&\n        JSON.stringify(item)\n          .toLowerCase()\n          .match(/wild armou{0,1}r/) === null\n      ) {\n        item.update({ \"data.equipped\": status });\n      } else {\n        item.update({ \"data.equipped\": true });\n      }\n    });\n};\n\nconst transform = (caster, token, name) => {\n  const creature = transformationOptions[name];\n  const changes = createBuffChanges(name);\n\n  const buff = getWSBuff(caster);\n  buff.update({ \"data.changes\": changes });\n  buff.update({ \"data.active\": true });\n\n  token.update({ img: `${imageFolder}/${name}.webp` });\n  caster.update({ \"data.traits.size\": sizeTranslation[creature.size] });\n\n  setArmourAndShieldEquipStatus(caster, false);\n};\n\nconst revertForm = (caster, token) => {\n  getWSBuff(caster).update({ \"data.active\": false });\n  token.update({ img: originalImage });\n  caster.update({ \"data.traits.size\": sizeTranslation[originalSize] });\n  setArmourAndShieldEquipStatus(caster, true);\n};\n\nconst kitsuneForm = (caster, token) => {\n  getWSBuff(caster).update({ \"data.active\": false });\n  token.update({ img: kitsuneImage });\n  caster.update({ \"data.traits.size\": sizeTranslation[originalSize] });\n  setArmourAndShieldEquipStatus(caster, true);\n};\n\nconst tokens = canvas.tokens.controlled;\n\nif (tokens.length !== 1) {\n  ui.notifications.warn(\"Select a token.\");\n} else {\n  const token = tokens[0];\n  const actor = token.actor;\n  const caster = actor.data;\n\n  const buttons = Object.keys(transformationOptions).map((optionName) => ({\n    label: optionName,\n    callback: () => transform(actor, token, optionName),\n  }));\n  buttons[\"Kitsune\"] = {\n    label: \"Kitsune\",\n    icon: '<i class=\"fas fa-user\"></i>',\n    callback: () => kitsuneForm(actor, token),\n  };\n  buttons[\"Revert\"] = {\n    label: \"Revert\",\n    icon: '<i class=\"fas fa-user\"></i>',\n    callback: () => revertForm(actor, token),\n  };\n\n  new Dialog({\n    title: \"Beast Shape\",\n    content: \"Choose creature.\",\n    buttons: buttons,\n  }).render(true);\n}","author":"fRudea7oGPoV9HaK","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"Kfwcw0qhtYrvdgcT"}
{"name":"EvaVanishingTrick","permission":{"default":0,"fRudea7oGPoV9HaK":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.O9yc5XFRTueAO7Of"}},"scope":"global","command":"const tokens = canvas.tokens.controlled;\n\nif (tokens.length !== 1) {\n  ui.notifications.warn(\"Select a token.\");\n} else {\n\ngame.cub.addCondition(\"Invisible\");\n\nconst alertData = {\n    round: 7, // this, combined with \"roundAbsolute: false\", indicates that the alert will trigger one round from the current round.\n    roundAbsolute: false, // indicates that the \"round\" field is relative to the \"createdRound\"\n    turnId: game.combat.combatant._id, // the alert will trigger on the turn it was created on\n    message: \"It might be time to remove Invisibility! @Macro[InvisRemove]\", // the chat message that will be displayed when the alert is triggered\n    recipientIds: game.users.filter((u) => u.isGM).map((u) => u.data._id),\n}\n\nTurnAlert.create(alertData); // Create a new turn alert with no confirmation\n}","author":"fRudea7oGPoV9HaK","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"zt2xzMPxp6b51eRq"}
